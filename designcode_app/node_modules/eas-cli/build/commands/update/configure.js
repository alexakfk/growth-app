"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const config_1 = require("@expo/config");
const eas_build_job_1 = require("@expo/eas-build-job");
const core_1 = require("@oclif/core");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const api_1 = require("../../api");
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const generated_1 = require("../../graphql/generated");
const log_1 = tslib_1.__importStar(require("../../log"));
const platform_1 = require("../../platform");
const projectUtils_1 = require("../../project/projectUtils");
const workflow_1 = require("../../project/workflow");
const UpdatesModule_1 = require("../../update/android/UpdatesModule");
const UpdatesModule_2 = require("../../update/ios/UpdatesModule");
const DEFAULT_MANAGED_RUNTIME_VERSION = { policy: 'sdkVersion' };
const DEFAULT_BARE_RUNTIME_VERSION = '1.0.0';
class UpdateConfigure extends EasCommand_1.default {
    async runAsync() {
        log_1.default.log('ðŸ’¡ The following process will configure your project to run EAS Update. These changes only apply to your local project files and you can safely revert them at any time.');
        const { flags } = await this.parse(UpdateConfigure);
        const { projectConfig: { projectId, exp, projectDir }, loggedIn: { graphqlClient }, } = await this.getContextAsync(UpdateConfigure, {
            nonInteractive: true,
        });
        const platform = flags.platform;
        if (!(0, projectUtils_1.isExpoUpdatesInstalledOrAvailable)(projectDir, exp.sdkVersion)) {
            await (0, projectUtils_1.installExpoUpdatesAsync)(projectDir);
        }
        const [androidWorkflow, iosWorkflow] = await Promise.all([
            (0, workflow_1.resolveWorkflowAsync)(projectDir, eas_build_job_1.Platform.ANDROID),
            (0, workflow_1.resolveWorkflowAsync)(projectDir, eas_build_job_1.Platform.IOS),
        ]);
        const updatedExp = await configureAppJSONForEASUpdateAsync({
            projectDir,
            exp,
            platform,
            workflows: {
                android: androidWorkflow,
                ios: iosWorkflow,
            },
            projectId,
        });
        log_1.default.withTick(`Configured ${chalk_1.default.bold('app.json')} for EAS Update`);
        // configure native files for EAS Update
        if ([platform_1.RequestedPlatform.Android, platform_1.RequestedPlatform.All].includes(platform) &&
            androidWorkflow === eas_build_job_1.Workflow.GENERIC) {
            await (0, UpdatesModule_1.syncUpdatesConfigurationAsync)(graphqlClient, projectDir, updatedExp, projectId);
            log_1.default.withTick(`Configured ${chalk_1.default.bold('AndroidManifest.xml')} for EAS Update`);
        }
        if ([platform_1.RequestedPlatform.Ios, platform_1.RequestedPlatform.All].includes(platform) &&
            iosWorkflow === eas_build_job_1.Workflow.GENERIC) {
            await (0, UpdatesModule_2.syncUpdatesConfigurationAsync)(graphqlClient, projectDir, updatedExp, projectId);
            log_1.default.withTick(`Configured ${chalk_1.default.bold('Expo.plist')} for EAS Update`);
        }
        log_1.default.addNewLineIfNone();
        log_1.default.warn(`All builds of your app going forward will be eligible to receive updates published with EAS Update.`);
        log_1.default.addNewLineIfNone();
        log_1.default.log(`ðŸŽ‰ Your app is configured to run EAS Update!`);
    }
}
exports.default = UpdateConfigure;
_a = UpdateConfigure;
UpdateConfigure.description = 'configure the project to support EAS Update';
UpdateConfigure.flags = {
    platform: core_1.Flags.enum({
        description: 'Platform to configure',
        char: 'p',
        options: ['android', 'ios', 'all'],
        default: 'all',
    }),
};
UpdateConfigure.contextDefinition = {
    ..._a.ContextOptions.ProjectConfig,
    ..._a.ContextOptions.LoggedIn,
};
async function configureAppJSONForEASUpdateAsync({ projectDir, exp, platform, workflows, projectId, }) {
    var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
    // this command is non-interactive in the way it was designed
    const easUpdateURL = (0, api_1.getEASUpdateURL)(projectId);
    const updates = { ...exp.updates, url: easUpdateURL };
    const androidDefaultRuntimeVersion = workflows['android'] === eas_build_job_1.Workflow.GENERIC
        ? DEFAULT_BARE_RUNTIME_VERSION
        : DEFAULT_MANAGED_RUNTIME_VERSION;
    const iosDefaultRuntimeVersion = workflows['ios'] === eas_build_job_1.Workflow.GENERIC
        ? DEFAULT_BARE_RUNTIME_VERSION
        : DEFAULT_MANAGED_RUNTIME_VERSION;
    const newAndroidRuntimeVersion = (_d = (_c = (_b = exp.android) === null || _b === void 0 ? void 0 : _b.runtimeVersion) !== null && _c !== void 0 ? _c : exp.runtimeVersion) !== null && _d !== void 0 ? _d : androidDefaultRuntimeVersion;
    const newIosRuntimeVersion = (_g = (_f = (_e = exp.ios) === null || _e === void 0 ? void 0 : _e.runtimeVersion) !== null && _f !== void 0 ? _f : exp.runtimeVersion) !== null && _g !== void 0 ? _g : iosDefaultRuntimeVersion;
    let newConfig;
    let newConfigOnlyAddedValues;
    switch (platform) {
        case platform_1.RequestedPlatform.All: {
            if (isRuntimeEqual(newAndroidRuntimeVersion, newIosRuntimeVersion)) {
                newConfig = {
                    runtimeVersion: newAndroidRuntimeVersion,
                    android: {
                        ...exp.android,
                        runtimeVersion: undefined,
                    },
                    ios: { ...exp.ios, runtimeVersion: undefined },
                    updates,
                };
                newConfigOnlyAddedValues = {
                    runtimeVersion: newAndroidRuntimeVersion,
                    ...(exp.android && 'runtimeVersion' in exp.android
                        ? {
                            android: {
                                runtimeVersion: '<remove this key>',
                            },
                        }
                        : {}),
                    ...(exp.ios && 'runtimeVersion' in exp.ios
                        ? {
                            ios: {
                                runtimeVersion: '<remove this key>',
                            },
                        }
                        : {}),
                    updates: {
                        url: easUpdateURL,
                    },
                };
            }
            else {
                newConfig = {
                    runtimeVersion: undefined,
                    android: {
                        ...exp.android,
                        runtimeVersion: newAndroidRuntimeVersion,
                    },
                    ios: {
                        ...exp.ios,
                        runtimeVersion: newIosRuntimeVersion,
                    },
                    updates,
                };
                newConfigOnlyAddedValues = {
                    ...('runtimeVersion' in exp
                        ? {
                            runtimeVersion: '<remove this key>', // top level runtime is redundant if it is specified in both android and ios
                        }
                        : {}),
                    android: {
                        runtimeVersion: newAndroidRuntimeVersion,
                    },
                    ios: {
                        runtimeVersion: newIosRuntimeVersion,
                    },
                    updates: {
                        url: easUpdateURL,
                    },
                };
            }
            break;
        }
        case platform_1.RequestedPlatform.Android: {
            newConfig = {
                android: {
                    ...exp.android,
                    runtimeVersion: newAndroidRuntimeVersion,
                },
                updates,
            };
            newConfigOnlyAddedValues = {
                android: {
                    runtimeVersion: newAndroidRuntimeVersion,
                },
                updates: {
                    url: easUpdateURL,
                },
            };
            break;
        }
        case platform_1.RequestedPlatform.Ios: {
            newConfig = {
                ios: {
                    ...exp.ios,
                    runtimeVersion: newIosRuntimeVersion,
                },
                updates,
            };
            newConfigOnlyAddedValues = {
                ios: {
                    runtimeVersion: newIosRuntimeVersion,
                },
                updates: {
                    url: easUpdateURL,
                },
            };
            break;
        }
        default: {
            throw new Error(`Unsupported platform: ${platform}`);
        }
    }
    const result = await (0, config_1.modifyConfigAsync)(projectDir, newConfig);
    const preexistingAndroidRuntimeVersion = (_j = (_h = exp.android) === null || _h === void 0 ? void 0 : _h.runtimeVersion) !== null && _j !== void 0 ? _j : exp.runtimeVersion;
    const preexistingIosRuntimeVersion = (_l = (_k = exp.ios) === null || _k === void 0 ? void 0 : _k.runtimeVersion) !== null && _l !== void 0 ? _l : exp.runtimeVersion;
    switch (result.type) {
        case 'success':
            if ((_m = exp.updates) === null || _m === void 0 ? void 0 : _m.url) {
                if (exp.updates.url !== easUpdateURL) {
                    log_1.default.withTick(`Overwrote "${(_o = exp.updates) === null || _o === void 0 ? void 0 : _o.url}" with "${easUpdateURL}" for the updates.url value in app.json`);
                }
            }
            else {
                log_1.default.withTick(`Set updates.url value, to "${easUpdateURL}" in app.json`);
            }
            if (!preexistingAndroidRuntimeVersion &&
                [platform_1.RequestedPlatform.Android, platform_1.RequestedPlatform.All].includes(platform)) {
                log_1.default.withTick(`Set ${platform_1.appPlatformDisplayNames[generated_1.AppPlatform.Android]} runtimeVersion to "${JSON.stringify((_q = (_p = newConfig.android) === null || _p === void 0 ? void 0 : _p.runtimeVersion) !== null && _q !== void 0 ? _q : newConfig.runtimeVersion)}" in app.json`);
            }
            if (!preexistingIosRuntimeVersion &&
                [platform_1.RequestedPlatform.Ios, platform_1.RequestedPlatform.All].includes(platform)) {
                log_1.default.withTick(`Set ${platform_1.appPlatformDisplayNames[generated_1.AppPlatform.Ios]} runtimeVersion to "${JSON.stringify((_s = (_r = newConfig.ios) === null || _r === void 0 ? void 0 : _r.runtimeVersion) !== null && _s !== void 0 ? _s : newConfig.runtimeVersion)}" in app.json`);
            }
            break;
        case 'warn': {
            log_1.default.addNewLineIfNone();
            log_1.default.warn(`It looks like you are using a dynamic configuration! ${(0, log_1.learnMore)('https://docs.expo.dev/workflow/configuration/#dynamic-configuration-with-appconfigjs)')}`);
            log_1.default.warn(`In order to finish configuring your project for EAS Update, you are going to need manually add the following to your app.config.js:\n${(0, log_1.learnMore)('https://expo.fyi/eas-update-config.md')}\n`);
            log_1.default.log(chalk_1.default.bold(JSON.stringify(newConfigOnlyAddedValues, null, 2)));
            log_1.default.addNewLineIfNone();
            if (workflows['android'] === eas_build_job_1.Workflow.GENERIC || workflows['ios'] === eas_build_job_1.Workflow.GENERIC) {
                log_1.default.warn(`You will also have to manually edit the projects ${chalk_1.default.bold('Expo.plist/AndroidManifest.xml')}. ${(0, log_1.learnMore)('https://expo.fyi/eas-update-config.md#native-configuration')}`);
            }
            log_1.default.addNewLineIfNone();
            throw new Error(result.message);
        }
        case 'fail':
            throw new Error(result.message);
        default:
            throw new Error('Unexpected result type from modifyConfigAsync');
    }
    (0, assert_1.default)(result.config, 'A successful result should have a config');
    return result.config.expo;
}
function isRuntimeEqual(runtimeVersionA, runtimeVersionB) {
    if (typeof runtimeVersionA === 'string' && typeof runtimeVersionB === 'string') {
        return runtimeVersionA === runtimeVersionB;
    }
    else if (typeof runtimeVersionA === 'object' && typeof runtimeVersionB === 'object') {
        return runtimeVersionA.policy === runtimeVersionB.policy;
    }
    else {
        return false;
    }
}
