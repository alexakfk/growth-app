"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.truncatePublishUpdateMessage = exports.ensureBranchExistsAsync = exports.defaultPublishPlatforms = void 0;
const tslib_1 = require("tslib");
const config_plugins_1 = require("@expo/config-plugins");
const eas_build_job_1 = require("@expo/eas-build-job");
const core_1 = require("@oclif/core");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const nullthrows_1 = tslib_1.__importDefault(require("nullthrows"));
const api_1 = require("../../api");
const queries_1 = require("../../branch/queries");
const utils_1 = require("../../branch/utils");
const url_1 = require("../../build/utils/url");
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const flags_1 = require("../../commandUtils/flags");
const pagination_1 = require("../../commandUtils/pagination");
const fetch_1 = tslib_1.__importDefault(require("../../fetch"));
const generated_1 = require("../../graphql/generated");
const PublishMutation_1 = require("../../graphql/mutations/PublishMutation");
const BranchQuery_1 = require("../../graphql/queries/BranchQuery");
const UpdateQuery_1 = require("../../graphql/queries/UpdateQuery");
const log_1 = tslib_1.__importStar(require("../../log"));
const ora_1 = require("../../ora");
const projectUtils_1 = require("../../project/projectUtils");
const publish_1 = require("../../project/publish");
const workflow_1 = require("../../project/workflow");
const prompts_1 = require("../../prompts");
const queries_2 = require("../../update/queries");
const utils_2 = require("../../update/utils");
const code_signing_1 = require("../../utils/code-signing");
const formatFields_1 = tslib_1.__importDefault(require("../../utils/formatFields"));
const json_1 = require("../../utils/json");
const statuspageService_1 = require("../../utils/statuspageService");
const vcs_1 = require("../../vcs");
const create_1 = require("../branch/create");
const create_2 = require("../channel/create");
exports.defaultPublishPlatforms = ['android', 'ios'];
async function ensureChannelExistsAsync(graphqlClient, { appId, branchId, channelName, }) {
    var _b;
    try {
        await (0, create_2.createUpdateChannelOnAppAsync)(graphqlClient, {
            appId,
            channelName,
            branchId,
        });
        log_1.default.withTick(`Created a channel: ${chalk_1.default.bold(channelName)} pointed at branch: ${chalk_1.default.bold(channelName)}.`);
    }
    catch (e) {
        const isIgnorableError = ((_b = e.graphQLErrors) === null || _b === void 0 ? void 0 : _b.length) === 1 &&
            e.graphQLErrors[0].extensions.errorCode === 'CHANNEL_ALREADY_EXISTS';
        if (!isIgnorableError) {
            throw e;
        }
    }
}
async function ensureBranchExistsAsync(graphqlClient, { appId, name: branchName }) {
    try {
        const updateBranch = await BranchQuery_1.BranchQuery.getBranchByNameAsync(graphqlClient, {
            appId,
            name: branchName,
        });
        const { id } = updateBranch;
        await ensureChannelExistsAsync(graphqlClient, { appId, branchId: id, channelName: branchName });
        return { branchId: id };
    }
    catch (error) {
        if (error instanceof utils_1.BranchNotFoundError) {
            const newUpdateBranch = await (0, create_1.createUpdateBranchOnAppAsync)(graphqlClient, {
                appId,
                name: branchName,
            });
            log_1.default.withTick(`Created branch: ${chalk_1.default.bold(branchName)}`);
            await ensureChannelExistsAsync(graphqlClient, {
                appId,
                branchId: newUpdateBranch.id,
                channelName: branchName,
            });
            return { branchId: newUpdateBranch.id };
        }
        else {
            throw error;
        }
    }
}
exports.ensureBranchExistsAsync = ensureBranchExistsAsync;
class UpdatePublish extends EasCommand_1.default {
    async runAsync() {
        var _b, _c, _d;
        const { flags } = await this.parse(UpdatePublish);
        const paginatedQueryOptions = (0, pagination_1.getPaginatedQueryOptions)(flags);
        let { branch: branchName, auto: autoFlag, message, republish, group, 'input-dir': inputDir, 'skip-bundler': skipBundler, platform, 'private-key-path': privateKeyPath, 'non-interactive': nonInteractive, json: jsonFlag, } = flags;
        const { getDynamicProjectConfigAsync, loggedIn: { graphqlClient }, } = await this.getContextAsync(UpdatePublish, {
            nonInteractive,
        });
        if (jsonFlag) {
            (0, json_1.enableJsonOutput)();
        }
        const platformFlag = platform;
        // If a group was specified, that means we are republishing it.
        republish = republish || !!group;
        const { exp, projectId, projectDir } = await getDynamicProjectConfigAsync({
            isPublicConfig: true,
        });
        const { exp: expPrivate } = await getDynamicProjectConfigAsync({
            isPublicConfig: false,
        });
        await (0, statuspageService_1.maybeWarnAboutEasOutagesAsync)(graphqlClient, [generated_1.StatuspageServiceName.EasUpdate]);
        const codeSigningInfo = await (0, code_signing_1.getCodeSigningInfoAsync)(expPrivate, privateKeyPath);
        const hasExpoUpdates = (0, projectUtils_1.isExpoUpdatesInstalledOrAvailable)(projectDir, exp.sdkVersion);
        if (!hasExpoUpdates && nonInteractive) {
            core_1.Errors.error(`${chalk_1.default.bold('expo-updates')} must already be installed when executing in non-interactive mode`, { exit: 1 });
        }
        if (!hasExpoUpdates) {
            const install = await (0, prompts_1.confirmAsync)({
                message: (0, chalk_1.default) `The module {cyan expo-updates} must be installed to load EAS updates in-app. Install?`,
                instructions: 'The command will abort unless you agree.',
            });
            if (install) {
                await (0, projectUtils_1.installExpoUpdatesAsync)(projectDir);
            }
            else {
                core_1.Errors.error(`Install ${chalk_1.default.bold('expo-updates')} and try again.`, {
                    exit: 1,
                });
            }
        }
        const runtimeVersions = await getRuntimeVersionObjectAsync(exp, platformFlag, projectDir);
        await checkEASUpdateURLIsSetAsync(exp, projectId);
        if (!branchName) {
            if (autoFlag) {
                branchName = await (0, utils_1.getDefaultBranchNameAsync)();
            }
            else if (nonInteractive) {
                throw new Error('Must supply --branch or use --auto when in non-interactive mode');
            }
            else {
                try {
                    const branch = await (0, queries_1.selectBranchOnAppAsync)(graphqlClient, {
                        projectId,
                        promptTitle: `Which branch would you like to ${republish ? 'republish' : 'publish'} on?`,
                        displayTextForListItem: updateBranch => `${updateBranch.name} ${chalk_1.default.grey(`- current update: ${(0, utils_2.formatUpdateMessage)(updateBranch.updates[0])}`)}`,
                        paginatedQueryOptions,
                    });
                    branchName = branch.name;
                }
                catch {
                    // unable to select a branch (network error or no branches for project)
                    ({ name: branchName } = await (0, prompts_1.promptAsync)({
                        type: 'text',
                        name: 'name',
                        message: 'No branches found. Provide a branch name:',
                        initial: await (0, utils_1.getDefaultBranchNameAsync)(),
                        validate: value => (value ? true : 'Branch name may not be empty.'),
                    }));
                }
                (0, assert_1.default)(branchName, 'Branch name must be specified.');
            }
        }
        let unsortedUpdateInfoGroups = {};
        let oldMessage, oldRuntimeVersion;
        let uploadedAssetCount = 0;
        let assetLimitPerUpdateGroup = 0;
        if (republish) {
            // If we are republishing, we don't need to worry about building the bundle or uploading the assets.
            // Instead we get the `updateInfoGroup` from the update we wish to republish.
            let updatesToRepublish;
            if (group) {
                const updatesByGroup = await UpdateQuery_1.UpdateQuery.viewUpdateGroupAsync(graphqlClient, {
                    groupId: group,
                });
                updatesToRepublish = updatesByGroup;
            }
            else {
                if (nonInteractive) {
                    throw new Error('Must supply --group when in non-interactive mode');
                }
                updatesToRepublish = await (0, queries_2.selectUpdateGroupOnBranchAsync)(graphqlClient, {
                    projectId,
                    branchName,
                    paginatedQueryOptions,
                });
            }
            const updatesToRepublishFilteredByPlatform = updatesToRepublish.filter(
            // Only republish to the specified platforms
            update => platformFlag === 'all' || update.platform === platformFlag);
            if (updatesToRepublishFilteredByPlatform.length === 0) {
                throw new Error(`There are no updates on branch "${branchName}" published for the platform(s) "${platformFlag}" with group ID "${group ? group : updatesToRepublish[0].group}". Did you mean to publish a new update instead?`);
            }
            let publicationPlatformMessage;
            if (platformFlag === 'all') {
                if (updatesToRepublishFilteredByPlatform.length !== exports.defaultPublishPlatforms.length) {
                    log_1.default.warn(`You are republishing an update that wasn't published for all platforms.`);
                }
                publicationPlatformMessage = `The republished update will appear on the same plaforms it was originally published on: ${updatesToRepublishFilteredByPlatform
                    .map(update => update.platform)
                    .join(', ')}`;
            }
            else {
                publicationPlatformMessage = `The republished update will appear only on: ${platformFlag}`;
            }
            log_1.default.withTick(publicationPlatformMessage);
            for (const update of updatesToRepublishFilteredByPlatform) {
                const { manifestFragment } = update;
                const platform = update.platform;
                unsortedUpdateInfoGroups[platform] = JSON.parse(manifestFragment);
            }
            // These are the same for each member of an update group
            group = updatesToRepublishFilteredByPlatform[0].group;
            oldMessage = (_b = updatesToRepublishFilteredByPlatform[0].message) !== null && _b !== void 0 ? _b : '';
            oldRuntimeVersion = updatesToRepublishFilteredByPlatform[0].runtimeVersion;
            if (!message) {
                if (nonInteractive) {
                    throw new Error('Must supply --message when in non-interactive mode');
                }
                const validationMessage = 'publish message may not be empty.';
                if (jsonFlag) {
                    throw new Error(validationMessage);
                }
                ({ publishMessage: message } = await (0, prompts_1.promptAsync)({
                    type: 'text',
                    name: 'publishMessage',
                    message: `Provide an update message.`,
                    initial: `Republish "${oldMessage}" - group: ${group}`,
                    validate: (value) => (value ? true : validationMessage),
                }));
            }
        }
        else {
            if (!message && autoFlag) {
                message = (_c = (await (0, vcs_1.getVcsClient)().getLastCommitMessageAsync())) === null || _c === void 0 ? void 0 : _c.trim();
            }
            if (!message) {
                if (nonInteractive) {
                    throw new Error('Must supply --message or use --auto when in non-interactive mode');
                }
                const validationMessage = 'publish message may not be empty.';
                if (jsonFlag) {
                    throw new Error(validationMessage);
                }
                ({ publishMessage: message } = await (0, prompts_1.promptAsync)({
                    type: 'text',
                    name: 'publishMessage',
                    message: `Provide an update message.`,
                    initial: (_d = (await (0, vcs_1.getVcsClient)().getLastCommitMessageAsync())) === null || _d === void 0 ? void 0 : _d.trim(),
                    validate: (value) => (value ? true : validationMessage),
                }));
            }
            // build bundle and upload assets for a new publish
            if (!skipBundler) {
                const bundleSpinner = (0, ora_1.ora)().start('Building bundle...');
                try {
                    await (0, publish_1.buildBundlesAsync)({ projectDir, inputDir });
                    bundleSpinner.succeed('Built bundle!');
                }
                catch (e) {
                    bundleSpinner.fail('Failed to build bundle!');
                    throw e;
                }
            }
            const assetSpinner = (0, ora_1.ora)().start('Uploading assets...');
            try {
                const platforms = platformFlag === 'all' ? exports.defaultPublishPlatforms : [platformFlag];
                const assets = await (0, publish_1.collectAssetsAsync)({ inputDir: inputDir, platforms });
                const uploadResults = await (0, publish_1.uploadAssetsAsync)(graphqlClient, assets, projectId, (totalAssets, missingAssets) => {
                    assetSpinner.text = `Uploading assets. Finished (${totalAssets - missingAssets}/${totalAssets})`;
                });
                uploadedAssetCount = uploadResults.uniqueUploadedAssetCount;
                assetLimitPerUpdateGroup = uploadResults.assetLimitPerUpdateGroup;
                unsortedUpdateInfoGroups = await (0, publish_1.buildUnsortedUpdateInfoGroupAsync)(assets, exp);
                const uploadAssetSuccessMessage = uploadedAssetCount
                    ? `Uploaded ${uploadedAssetCount} ${uploadedAssetCount === 1 ? 'asset' : 'assets'}!`
                    : `Uploading assets skipped -- no new assets found!`;
                assetSpinner.succeed(uploadAssetSuccessMessage);
            }
            catch (e) {
                assetSpinner.fail('Failed to upload assets');
                throw e;
            }
        }
        const truncatedMessage = (0, exports.truncatePublishUpdateMessage)(message);
        const runtimeToPlatformMapping = {};
        for (const runtime of new Set(Object.values(runtimeVersions))) {
            runtimeToPlatformMapping[runtime] = Object.entries(runtimeVersions)
                .filter(pair => pair[1] === runtime)
                .map(pair => pair[0]);
        }
        const { branchId } = await ensureBranchExistsAsync(graphqlClient, {
            appId: projectId,
            name: branchName,
        });
        // Sort the updates into different groups based on their platform specific runtime versions
        const updateGroups = Object.entries(runtimeToPlatformMapping).map(([runtime, platforms]) => {
            const localUpdateInfoGroup = Object.fromEntries(platforms.map(platform => [
                platform,
                unsortedUpdateInfoGroups[platform],
            ]));
            if (republish && !oldRuntimeVersion) {
                throw new Error('Cannot find the runtime version of the update group that is being republished.');
            }
            return {
                branchId,
                updateInfoGroup: localUpdateInfoGroup,
                runtimeVersion: republish ? oldRuntimeVersion : runtime,
                message: truncatedMessage,
                awaitingCodeSigningInfo: !!codeSigningInfo,
            };
        });
        let newUpdates;
        const publishSpinner = (0, ora_1.ora)('Publishing...').start();
        try {
            newUpdates = await PublishMutation_1.PublishMutation.publishUpdateGroupAsync(graphqlClient, updateGroups);
            if (codeSigningInfo) {
                log_1.default.log('🔒 Signing updates');
                const updatesTemp = [...newUpdates];
                const updateGroupsAndTheirUpdates = updateGroups.map(updateGroup => {
                    const newUpdates = updatesTemp.splice(0, Object.keys(updateGroup.updateInfoGroup).length);
                    return {
                        updateGroup,
                        newUpdates,
                    };
                });
                await Promise.all(updateGroupsAndTheirUpdates.map(async ({ updateGroup, newUpdates }) => {
                    await Promise.all(newUpdates.map(async (newUpdate) => {
                        const response = await (0, fetch_1.default)(newUpdate.manifestPermalink, {
                            method: 'GET',
                            headers: { accept: 'multipart/mixed' },
                        });
                        const manifestBody = (0, nullthrows_1.default)(await (0, code_signing_1.getManifestBodyAsync)(response));
                        (0, code_signing_1.checkManifestBodyAgainstUpdateInfoGroup)(manifestBody, (0, nullthrows_1.default)(updateGroup.updateInfoGroup[newUpdate.platform]));
                        const manifestSignature = (0, code_signing_1.signManifestBody)(manifestBody, codeSigningInfo);
                        await PublishMutation_1.PublishMutation.setCodeSigningInfoAsync(graphqlClient, newUpdate.id, {
                            alg: codeSigningInfo.codeSigningMetadata.alg,
                            keyid: codeSigningInfo.codeSigningMetadata.keyid,
                            sig: manifestSignature,
                        });
                    }));
                }));
            }
            publishSpinner.succeed('Published!');
        }
        catch (e) {
            publishSpinner.fail('Failed to publish updates');
            throw e;
        }
        if (jsonFlag) {
            (0, json_1.printJsonOnlyOutput)(newUpdates);
        }
        else {
            if (new Set(newUpdates.map(update => update.group)).size > 1) {
                log_1.default.addNewLineIfNone();
                log_1.default.log('👉 Since multiple runtime versions are defined, multiple update groups have been published.');
            }
            log_1.default.addNewLineIfNone();
            for (const runtime of new Set(Object.values(runtimeVersions))) {
                const newUpdatesForRuntimeVersion = newUpdates.filter(update => update.runtimeVersion === runtime);
                if (newUpdatesForRuntimeVersion.length === 0) {
                    throw new Error(`Publish response is missing updates with runtime ${runtime}.`);
                }
                const platforms = newUpdatesForRuntimeVersion.map(update => update.platform);
                const newAndroidUpdate = newUpdatesForRuntimeVersion.find(update => update.platform === 'android');
                const newIosUpdate = newUpdatesForRuntimeVersion.find(update => update.platform === 'ios');
                const updateGroupId = newUpdatesForRuntimeVersion[0].group;
                const projectName = exp.slug;
                const accountName = (await (0, projectUtils_1.getOwnerAccountForProjectIdAsync)(graphqlClient, projectId)).name;
                const updateGroupUrl = (0, url_1.getUpdateGroupUrl)(accountName, projectName, updateGroupId);
                const updateGroupLink = (0, log_1.link)(updateGroupUrl, { dim: false });
                log_1.default.log((0, formatFields_1.default)([
                    { label: 'Branch', value: branchName },
                    { label: 'Runtime version', value: runtime },
                    { label: 'Platform', value: platforms.join(', ') },
                    { label: 'Update group ID', value: updateGroupId },
                    ...(newAndroidUpdate
                        ? [{ label: 'Android update ID', value: newAndroidUpdate.id }]
                        : []),
                    ...(newIosUpdate ? [{ label: 'iOS update ID', value: newIosUpdate.id }] : []),
                    { label: 'Message', value: truncatedMessage },
                    { label: 'Website link', value: updateGroupLink },
                ]));
                log_1.default.addNewLineIfNone();
                if ((0, publish_1.isUploadedAssetCountAboveWarningThreshold)(uploadedAssetCount, assetLimitPerUpdateGroup)) {
                    log_1.default.warn(`This update group contains ${uploadedAssetCount} assets and is nearing the server cap of ${assetLimitPerUpdateGroup}.\n` +
                        `${(0, log_1.learnMore)('https://docs.expo.dev/eas-update/optimize-assets/', {
                            learnMoreMessage: 'Consider optimizing your usage of assets',
                            dim: false,
                        })}.`);
                    log_1.default.addNewLineIfNone();
                }
            }
        }
    }
}
exports.default = UpdatePublish;
_a = UpdatePublish;
UpdatePublish.description = 'publish an update group';
UpdatePublish.flags = {
    branch: core_1.Flags.string({
        description: 'Branch to publish the update group on',
        required: false,
    }),
    message: core_1.Flags.string({
        description: 'A short message describing the update',
        required: false,
    }),
    republish: core_1.Flags.boolean({
        description: 'Republish an update group',
        exclusive: ['input-dir', 'skip-bundler'],
    }),
    group: core_1.Flags.string({
        description: 'Update group to republish',
        exclusive: ['input-dir', 'skip-bundler'],
    }),
    'input-dir': core_1.Flags.string({
        description: 'Location of the bundle',
        default: 'dist',
        required: false,
    }),
    'skip-bundler': core_1.Flags.boolean({
        description: `Skip running Expo CLI to bundle the app before publishing`,
        default: false,
    }),
    platform: core_1.Flags.enum({
        char: 'p',
        options: [...exports.defaultPublishPlatforms, 'all'],
        default: 'all',
        required: false,
    }),
    auto: core_1.Flags.boolean({
        description: 'Use the current git branch and commit message for the EAS branch and update message',
        default: false,
    }),
    'private-key-path': core_1.Flags.string({
        description: `File containing the PEM-encoded private key corresponding to the certificate in expo-updates' configuration. Defaults to a file named "private-key.pem" in the certificate's directory.`,
        required: false,
    }),
    ...flags_1.EasNonInteractiveAndJsonFlags,
};
UpdatePublish.contextDefinition = {
    ..._a.ContextOptions.DynamicProjectConfig,
    ..._a.ContextOptions.LoggedIn,
};
async function getRuntimeVersionObjectAsync(exp, platformFlag, projectDir) {
    var _b, _c;
    const platforms = (platformFlag === 'all' ? ['android', 'ios'] : [platformFlag]);
    for (const platform of platforms) {
        const isPolicy = typeof ((_c = (_b = exp[platform]) === null || _b === void 0 ? void 0 : _b.runtimeVersion) !== null && _c !== void 0 ? _c : exp.runtimeVersion) === 'object';
        if (isPolicy) {
            const isManaged = (await (0, workflow_1.resolveWorkflowAsync)(projectDir, platform)) === eas_build_job_1.Workflow.MANAGED;
            if (!isManaged) {
                throw new Error('Runtime version policies are only supported in the managed workflow. In the bare workflow, runtime version needs to be set manually.');
            }
        }
    }
    return Object.fromEntries(platforms.map(platform => [
        platform,
        (0, nullthrows_1.default)(config_plugins_1.Updates.getRuntimeVersion(exp, platform), `Unable to determine runtime version for ${platform}`),
    ]));
}
async function checkEASUpdateURLIsSetAsync(exp, projectId) {
    var _b;
    const configuredURL = (_b = exp.updates) === null || _b === void 0 ? void 0 : _b.url;
    const expectedURL = (0, api_1.getEASUpdateURL)(projectId);
    if (configuredURL !== expectedURL) {
        throw new Error(`The update URL is incorrectly configured for EAS Update. Set updates.url to ${expectedURL} in your ${chalk_1.default.bold('app.json')}.`);
    }
}
const truncatePublishUpdateMessage = (originalMessage) => {
    if (originalMessage.length > 1024) {
        log_1.default.warn('Update message exceeds the allowed 1024 character limit. Truncating message...');
        return originalMessage.substring(0, 1021) + '...';
    }
    return originalMessage;
};
exports.truncatePublishUpdateMessage = truncatePublishUpdateMessage;
